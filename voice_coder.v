
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module voice_coder(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		reg     [6:0]		HEX0,
	output		reg     [6:0]		HEX1,
	output		reg     [6:0]		HEX2,
	output		reg     [6:0]		HEX3,
	output		reg     [6:0]		HEX4,
	output		reg     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clk_test;
wire clk_i2c;
wire reset;
wire [15:0] audiodata;
//wire [15:0] audiofifoin;
//wire [15:0] audiofifoout;
/*
wire rdemptyq2;
wire wrfullq2;
wire rdemptyq1;
wire wrfullq1;
*/
reg [9:0] rdaddr=0;    //输入队列读指针
reg [9:0] wraddr=0;    //输入队列写指针
reg rden = 1'b0;            //输入读使能
reg wren = 1'b1;            //输入写使能
reg flagread;
wire [15:0] audioout;  //输入队列的输出数据
wire [15:0] hanout;    //乘上了海明窗之后的输出
wire iff_eop;          //ifft的输出结束使能
wire iff_sop;          //ifft的输出开始信号
wire fft_ready;        //fft开始输入信号
wire [15:0] ifftout;   //ifft输出
reg [9:0] outqreadaddr = 10'b1100000001;   //输出队列读指针
reg [9:0] outqwriteaddr=0;  //输出队列写指针
wire [15:0] finaldata; //输出队列的输出数据
wire [15:0] outputdata;
wire outqren;          //输出队列的读使能
wire outqwen;          //输出队列的写使能
//wire CLK96k;      //96kHz 时钟

reg [9:0] cntwrite = 10'b1100000001;   //记录输入队列的写地址,每次256开始读使能有效
reg [9:0] cntread=0;     //记录输入队列读地址，每次512结束，读使能失效
reg [15:0] outq [0:1023];
reg [9:0] cntoutread=0;  //记录输入队列地写地址

reg [15:0] audiotest=0;
wire [15:0] audiod;
//=======================================================
//  Structural coding
//=======================================================
/*
initial
begin
    cntwrite = 10'b1100000001;
    outqreadaddr = 10'b10000001;
	//wren = 1'b1;
	//rden = 1'b1;
	wraddr = 1'b1;
	rdaddr = 0;
end 
*/

assign reset = ~KEY[0];

audio_clk u1(CLOCK_50, reset,AUD_XCK, LEDR[9]);

//I2C part
clkgen #(10000) my_i2c_clk(CLOCK_50,reset,1'b1,clk_i2c);  //10k I2C clock  
//clkgen #(100) my_i2c_clk1(CLOCK_50,reset,1'b1,clk_test);  //10Hz test clock  

I2C_Audio_Config myconfig(clk_i2c, KEY[0],FPGA_I2C_SCLK,FPGA_I2C_SDAT,LEDR[2:0]);

I2S_Audio myaudio(AUD_XCK, SW[0], LEDR[6], AUD_DACDAT, AUD_DACLRCK, audiod);

//Sin_Generator sin_wave(AUD_DACLRCK, KEY[0], 16'h0400, audiodata);//
I2S_Audioin myaudioin(AUD_XCK, KEY[0], AUD_BCLK, AUD_ADCDAT, AUD_ADCLRCK, audiodata);

//FIFO inq2(audiodata,AUD_ADCLRCK,SW[0],AUD_ADCLRCK,SW[1],audiofifoin,rdemptyq2,wrfullq2);
//FIFO inq1(audiofifoin,AUD_ADCLRCK,SW[0],AUD_ADCLRCK,SW[1],audiofifoout,rdemptyq1,wrfullq1);

//====================================
//输入缓冲队列
//读时钟50MHz,写时钟48kHz,写256开始读
//====================================
always @(posedge clk_test)
begin
  audiotest <= audiotest+1'b1;
end


ram2 inq1(audiodata,rdaddr,CLOCK_50,rden,wraddr,clk_test,wren,audioout);

//===============================
//for test
//===============================
always @(posedge AUD_ADCLRCK)
begin
  if(wren)
  begin
	if(cntwrite>=8'd255)
	begin
		//rden <= 1'b1;
		cntwrite <= 0;
	end
	else
	begin
		wraddr <= wraddr + 1'b1;
		cntwrite <= cntwrite + 1'b1;
	end
  end
end

always @(posedge CLOCK_50)
begin
  if(cntwrite == 8'd255 && flagread == 1'b1)
  begin
	rden <= 1'b1;
	if(cntread >= 9'd511)
	begin
	  cntread <= cntread-9'd256;
	  flagread <= 0;
	  rden <= 0;
	end
	else
	begin
	  rdaddr <= rdaddr + 1'b1;
	  cntread<=cntread + 1'b1;
	end
  end
  if(cntwrite==3'd4)
	flagread <= 1'b1;
end



//==================
//输入队列地址使能控制
//==================
/*
always @(posedge AUD_ADCLRCK)
begin
  wraddr<=wraddr+1'b1;
  rdaddr<=rdaddr+1'b1;
end
*/
/*
always @(posedge AUD_ADCLRCK)
begin
  if(wren)
  begin
	if(cntwrite==8'd255)
	begin
		cntwrite <= 1'b0;
		//rden <= 1'b1;
	end
	else
	begin
		wraddr <= wraddr+1'b1;
		cntwrite <= cntwrite+1'b1;
	end
  end
end

always @(posedge CLOCK_50)
begin
	if(cntwrite==8'd255 && flagread==1)
	begin
	  rden <=1'b1;
	  if(cntread>=9'd511)
	  begin
		rdaddr <= rdaddr - 9'd256;
		cntread <= 0;
		rden <= 0;
		flagread<=1'b0;
	  end
	  else
	  begin
		rdaddr <= rdaddr+1'b1;
		cntread <= cntread+1'b1;
	  end
	end
	if(cntwrite == 3'd4)
	begin
		flagread<=1'b1;
	end
end
*/
//====================================
//乘海明窗
//====================================
//mul_hanning hanning(CLOCK_50,audioout,hanout,cntread);

//=====================================
//fft和ifft
//=====================================
//fft_and_ifft myfft(CLOCK_50,rden,hanout,outqwen,ifftout);

//=====================================
//输出缓冲队列
//=====================================
//ram2 outq(ifftout,ifftread,AUD_ADCLRCK,1'b1,ifftwrite,CLOCK_50,outqwen,finaldata);
/*
always @(posedge CLOCK_50)
begin
  if(outqwen)
  begin
	if(cntoutread>=8'd255)
	begin
		if(cntoutread>=9'd511)
		begin
			cntoutread<=0;
			outqwriteaddr<=outqwriteaddr-9'd256;
		end
		else
		begin
			outq[outqwriteaddr] <= ifftout;
			//outq[outqwriteaddr] <= hanout;
			cntoutread <= cntoutread+1'b1;
			outqwriteaddr <= outqwriteaddr+1'b1;
		end
	end
	else
	begin
		outq[outqwriteaddr] <= outq[outqwriteaddr] + ifftout;
		//outq[outqwriteaddr] <= outq[outqwriteaddr] + hanout;
		outqwriteaddr<=outqwriteaddr+1'b1;
		cntoutread <= cntoutread+1'b1;
	end
  end
end


always @(posedge AUD_ADCLRCK)
begin
  outqreadaddr <= outqreadaddr+1'b1;
end
*/

//========================================
// test out que
//========================================


ram2 outq2(audioout,outqreadaddr,clk_test,1'b1,outqwriteaddr,CLOCK_50,rden,audiod);

always @(posedge CLOCK_50)
begin
  if(rden)
  begin
	if(cntoutread >= 8'd255)
	begin
	  if(cntoutread >= 9'd511)
	  begin
		cntoutread <= 0;
		outqwriteaddr <= outqwriteaddr-9'd256;
	  end
	  else
	  begin
		//outq[outqwriteaddr] <= audioout;
		outqwriteaddr <= outqwriteaddr+1'b1;
		cntoutread <= cntoutread +1'b1;
	  end
	end
	else
	begin
	  //outq[outqwriteaddr] <= audioout;
	  outqwriteaddr <= outqwriteaddr+1'b1;
	  cntoutread <= cntoutread + 1'b1;
	end
  end
end

always @(posedge AUD_ADCLRCK)
begin
	outqreadaddr <= outqreadaddr+1'b1;
end


//===================================
//for test
//===================================


//assign audiod = outq[outqreadaddr];

always @(*)
begin
	case(audiod[3:0])
		0: HEX0=7'b1000000;  //0
		1: HEX0=7'b1111001;  //1
		2: HEX0=7'b0100100;  //2
		3: HEX0=7'b0110000;  //3
		4: HEX0=7'b0011001;  //4
		5: HEX0=7'b0010010;  //5
		6: HEX0=7'b0000010;  //6
		7: HEX0=7'b1111000;  //7
		8: HEX0=7'b0000000;  //8
		9: HEX0=7'b0010000;  //9
		10: HEX0=7'b0001000;  //10
		11: HEX0=7'b0000011;  //11
		12: HEX0=7'b1000110;  //12
		13: HEX0=7'b0100001;  //13
		14: HEX0=7'b0000110;  //14
		15: HEX0=7'b0001110;  //15
		default: HEX0=7'b0000000;
	 endcase 
	 
	 case(audiod[7:4])
		0: HEX1=7'b1000000;  //0
		1: HEX1=7'b1111001;  //1
		2: HEX1=7'b0100100;  //2
		3: HEX1=7'b0110000;  //3
		4: HEX1=7'b0011001;  //4
		5: HEX1=7'b0010010;  //5
		6: HEX1=7'b0000010;  //6
		7: HEX1=7'b1111000;  //7
		8: HEX1=7'b0000000;  //8
		9: HEX1=7'b0010000;  //9
		10: HEX1=7'b0001000;  //10
		11: HEX1=7'b0000011;  //11
		12: HEX1=7'b1000110;  //12
		13: HEX1=7'b0100001;  //13
		14: HEX1=7'b0000110;  //14
		15: HEX1=7'b0001110;  //15
		default: HEX1=7'b0000000;
	 endcase 
	 
	 case(audiod[11:8])
		0: HEX2=7'b1000000;  //0
		1: HEX2=7'b1111001;  //1
		2: HEX2=7'b0100100;  //2
		3: HEX2=7'b0110000;  //3
		4: HEX2=7'b0011001;  //4
		5: HEX2=7'b0010010;  //5
		6: HEX2=7'b0000010;  //6
		7: HEX2=7'b1111000;  //7
		8: HEX2=7'b0000000;  //8
		9: HEX2=7'b0010000;  //9
		10: HEX2=7'b0001000;  //10
		11: HEX2=7'b0000011;  //11
		12: HEX2=7'b1000110;  //12
		13: HEX2=7'b0100001;  //13
		14: HEX2=7'b0000110;  //14
		15: HEX2=7'b0001110;  //15
		default: HEX2=7'b0000000;
	 endcase
	 
	 case(audiod[15:12])
		0: HEX3=7'b1000000;  //0
		1: HEX3=7'b1111001;  //1
		2: HEX3=7'b0100100;  //2
		3: HEX3=7'b0110000;  //3
		4: HEX3=7'b0011001;  //4
		5: HEX3=7'b0010010;  //5
		6: HEX3=7'b0000010;  //6
		7: HEX3=7'b1111000;  //7
		8: HEX3=7'b0000000;  //8
		9: HEX3=7'b0010000;  //9
		10: HEX3=7'b0001000;  //10
		11: HEX3=7'b0000011;  //11
		12: HEX3=7'b1000110;  //12
		13: HEX3=7'b0100001;  //13
		14: HEX3=7'b0000110;  //14
		15: HEX3=7'b0001110;  //15
		default: HEX3=7'b0000000;
	 endcase
end		


reg led;
always @(*)
begin
  if(rden)
	led=1'b1;
end

assign LEDR[8] = led;

endmodule
